@article{haskell_optimisations_1997,
author = {Peyton Jones, Simon and Santos, Andre},
title = {A transformation-based optimiser for Haskell},
year = {1997},
month = {October},
abstract = {Many compilers do some of their work by means of correctness-preserving, and hopefully performance-improving, program transformations. The Glasgow Haskell Compiler (GHC) takes this idea of "compilation by transformation" as its war-cry, trying to express as much as possible of the compilation process in the form of program transformations.

This paper reports on our practical experience of the transformational approach to compilation, in the context of a substantial compiler.


This is a journal version of "Compilation by program transformation: a report from the trenches" (ESOP'96)},
url = {https://www.microsoft.com/en-us/research/publication/a-transformation-based-optimiser-for-haskell/},
journal = {Science of Computer Programming},
volume = {32},
number = {1}
}


@article{WADLER1990231,
title = {Deforestation: transforming programs to eliminate trees},
journal = {Theoretical Computer Science},
volume = {73},
number = {2},
pages = {231-248},
year = {1990},
issn = {0304-3975},
doi = {https://doi.org/10.1016/0304-3975(90)90147-A},
url = {https://www.sciencedirect.com/science/article/pii/030439759090147A},
author = {Philip Wadler},
abstract = {An algorithm that transforms programs to eliminate intermediate trees is presented. The algorithm applies to any term containing only functions with definitions in a given syntactic form, and is suitable for incorporation in an optimizing compiler.}
}

@article{inspection_testing,
       author = {{Breitner}, Joachim},
        title = "{A promise checked is a promise kept: Inspection Testing}",
      journal = {arXiv e-prints},
     keywords = {Computer Science - Programming Languages},
         year = 2018,
        month = mar,
          eid = {arXiv:1803.07130},
        pages = {arXiv:1803.07130},
archivePrefix = {arXiv},
       eprint = {1803.07130},
 primaryClass = {cs.PL},
       adsurl = {https://ui.adsabs.harvard.edu/abs/2018arXiv180307130B},
      adsnote = {Provided by the SAO/NASA Astrophysics Data System}
}

@book{implementing_fl,
author = {Peyton Jones, Simon},
title = {The Implementation of Functional Programming Languages},
year = {1987},
month = {January},
abstract = {My 1987 book is now out of print, but it is available here in its entirety in PDF form, in one of two formats:

 	single-page portrait
 	double-page landscape

Both are fully searchable, thanks to OCR and Norman Ramsey.

Errata

 	Section 5.2.4, p87.  We need an extra rule

match us [] E = E
This accounts for the possibility that in the constructor rule (Section 5.2.4) there may be some non-nullary constructors for which there are no equations.


 	P168, line 2, "VAR" should be "TVAR".},
publisher = {Prentice Hall},
url = {https://www.microsoft.com/en-us/research/publication/the-implementation-of-functional-programming-languages/},
}

@misc{ghc_dump, 
    author = {Ben Gamari},
    title = {ghc-dump: https://github.com/bgamari/ghc-dump},
    year = 2019,
    url = {https://github.com/bgamari/ghc-dump},
    urldate = {2022-04-08}
}

@article{playing_by_the_rules,
author = {Peyton Jones, Simon and Tolmach, Andrew and Hoare, Tony},
year = {2001},
month = {04},
pages = {},
title = {Playing by the Rules: Rewriting as a practical optimisation technique in GHC},
journal = {Haskell 2001}
}

@misc{haskell_survey_2021, 
    url={https://taylor.fausak.me/2021/11/16/haskell-survey-results},
    title={2021 State of Haskell Survey Results: https://taylor.fausak.me/2021/11/16/haskell-survey-results},
    author={Taylor Fausak}
}

@book{optimisation_handbook,
author = {Young, Jeffry M.},
title = {The Haskell Optimization Handbook},
year = {2022},
publisher = {Haskell Foundation},
url = {https://github.com/input-output-hk/hs-opt-handbook.github.io},
}

@misc{ghc_wiki_core2core,
  url={https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/compiler/core-to-core-pipeline},
  title={GHC wiki: Core to Core pipeline},
  year={2022},
}

@misc{ghc_wiki_wwrapper,
  url={https://wiki.haskell.org/Worker_wrapper},
  title={GHC wiki: Worker wrapper},
  year={2022},
}

@article{secrets_of_the_inliner,
author = {Peyton Jones, Simon and Marlow, Simon},
title = {Secrets of the Glasgow Haskell Compiler inliner},
year = {2002},
month = {July},
abstract = {Higher-order languages, such as Haskell, encourage the programmer to build abstractions by composing functions. A good compiler must inline many of these calls to recover an efficiently executable program.

In principle, inlining is dead simple: just replace the call of a function by an instance of its body. But any compiler-writer will tell you that inlining is a black art, full of delicate compromises that work together to give good performance without unnecessary code bloat.

The purpose of this paper is, therefore, to articulate the key lessons we learned from a full-scale ``production'' inliner, the one used in the Glasgow Haskell compiler. We focus mainly on the algorithmic aspects, but we also provide some indicative measurements to substantiate the importance of various aspects of the inliner.

The "Related File" link above is an earlier tech-report version of the paper, but the JFP version is the one to read (the "View publication" button).},
url = {https://www.microsoft.com/en-us/research/publication/secrets-of-the-glasgow-haskell-compiler-inliner/},
pages = {393-434},
journal = {Journal of Functional Programming},
volume = {12},
}

@article{worker_wrapper,
author = {Gill, Andy and Hutton, Graham},
year = {2009},
month = {03},
pages = {},
title = {The worker/wrapper transformation},
volume = {19},
journal = {Journal of Functional Programming},
doi = {10.1017/S0956796809007175}
}

@article{shortcut_fusion,
author = {Gill, Andy and Launchbury, John and Peyton Jones, Simon},
year = {1995},
month = {04},
pages = {},
title = {A Short Cut to Deforestation},
journal = {[No source information available]},
doi = {10.1145/165180.165214}
}

@misc{shortcut_fusion_blog, 
    author = {Yul Seo, Kwang},
    title = {Short cut fusion: https://kseo.github.io/posts/2016-12-18-short-cut-fusion.html},
    year = 2016,
    url = {https://kseo.github.io/posts/2016-12-18-short-cut-fusion.html},
    urldate = {2022-10-17}
}

@inproceedings{inling_magic_numbers,
author = {Hollenbeck, Celeste and O'Boyle, Michael F. P. and Steuwer, Michel},
title = {Investigating Magic Numbers: Improving the Inlining Heuristic in the Glasgow Haskell Compiler},
year = {2022},
isbn = {9781450394383},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3546189.3549918},
doi = {10.1145/3546189.3549918},
abstract = {Inlining is a widely studied compiler optimization that is particularly important for functional languages such as Haskell and OCaml. The Glasgow Haskell Compiler (GHC) inliner is a heuristic of such complexity, however, that it has not significantly changed for nearly 20 years. It heavily relies on hard-coded numeric constants, or magic numbers, based on out-of-date intuition. Dissatisfaction with inlining performance has led to the widespread use of inlining pragmas by programmers. In this paper, we present an in-depth study of the effect of inlining on performance in functional languages. We specifically focus on the inlining behavior of GHC and present techniques to systematically explore the space of possible magic number values, or configurations, and evaluate their performance on a set of real-world benchmarks where inline pragmas are present. Pragmas may slow down individual programs, but on average improve performance by 10%. Searching for the best configuration on a per-program basis increases this performance to an average of 27%. Searching for the best configuration for each program is, however, expensive and unrealistic, requiring repeated compilation and execution. This paper determines a new single configuration that gives a 22% improvement on average across the benchmarks. Finally, we use a simple machine learning model that predicts the best configuration on a per-program basis, giving a 26% average improvement.},
booktitle = {Proceedings of the 15th ACM SIGPLAN International Haskell Symposium},
pages = {81–94},
numpages = {14},
keywords = {GHC, Inlining, Haskell},
location = {Ljubljana, Slovenia},
series = {Haskell 2022}
}

@misc{elm_lang, 
    url={https://https://elm-lang.org/},
    title={Elm: https://https://elm-lang.org/},
    author={Evan Czaplicki}
}

@inproceedings{hashing_mod_alpha,
author = {Maziarz, Krzysztof and Ellis, Tom and Lawrence, Alan and Fitzgibbon, Andrew and Peyton Jones, Simon},
title = {Hashing Modulo Alpha-Equivalence},
organization = {ACM},
booktitle = {ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI'21)},
year = {2021},
month = {June},
abstract = {In many applications one wants to identify identical subtrees of a program syntax tree.  This identification should ideally be robust to alpha-renaming of the program, but no existing technique has been shown to achieve this with good efficiency (better than O(n^2) in expression size). We present a new, asymptotically efficient way to hash modulo alpha-equivalence. A key insight of our method is to use a weak (commutative) hash combiner at exactly one point in the construction, which admits an algorithm with O(n*(log n)^2) time complexity. We prove that the use of the commutative combiner nevertheless yields a strong hash with low collision probability.},
publisher = {ACM},
url = {https://www.microsoft.com/en-us/research/publication/hashing-modulo-alpha-equivalence-2/},
}

@misc{haskell_to_elm,
   author = { Olle Fredriksson },
   title = { haskell-to-elm },
   howpublished = {\url{https://hackage.haskell.org/package/haskell-to-elm}},
   year = {2019}
}

@inproceedings{prettier_printer,
  title={A prettier printer},
  author={Philip Wadler and Joyce Kilmer},
  year={2002}
}

@misc{prettier_printer_elm,
   author = { pwentz },
   title = { elm-pretty-printer },
   howpublished = {\url{https://github.com/the-sett/elm-pretty-printer}},
   year = {2019}
}

@misc{pygments,
   author = { Georg Brandl, Matthäus Chajdas, Jean Abou-Samra },
   title = { pygments-pretty-printer },
   howpublished = {\url{https://pygments.org/}},
   year = {2019}
}

  @article{10.1145/3140587.3062380,
author = {Maurer, Luke and Downen, Paul and Ariola, Zena M. and Peyton Jones, Simon},
title = {Compiling without Continuations},
year = {2017},
issue_date = {June 2017},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {52},
number = {6},
issn = {0362-1340},
url = {https://doi.org/10.1145/3140587.3062380},
doi = {10.1145/3140587.3062380},
abstract = {Many fields of study in compilers give rise to the concept of a join point—a place where different execution paths come together. Join points are often treated as functions or continuations, but we believe it is time to study them in their own right. We show that adding join points to a direct-style functional intermediate language is a simple but powerful change that allows new optimizations to be performed, including a significant improvement to list fusion. Finally, we report on recent work on adding join points to the intermediate language of the Glasgow Haskell Compiler.},
journal = {SIGPLAN Not.},
month = {jun},
pages = {482–494},
numpages = {13},
keywords = {list fusion, GHC, CPS, ANF, intermediate languages, Haskell}
}

@inproceedings{compiling_wo_continuations,
author = {Maurer, Luke and Downen, Paul and Ariola, Zena M. and Peyton Jones, Simon},
title = {Compiling without Continuations},
year = {2017},
isbn = {9781450349888},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3062341.3062380},
doi = {10.1145/3062341.3062380},
abstract = {Many fields of study in compilers give rise to the concept of a join point—a place where different execution paths come together. Join points are often treated as functions or continuations, but we believe it is time to study them in their own right. We show that adding join points to a direct-style functional intermediate language is a simple but powerful change that allows new optimizations to be performed, including a significant improvement to list fusion. Finally, we report on recent work on adding join points to the intermediate language of the Glasgow Haskell Compiler.},
booktitle = {Proceedings of the 38th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {482–494},
numpages = {13},
keywords = {CPS, ANF, list fusion, intermediate languages, GHC, Haskell},
location = {Barcelona, Spain},
series = {PLDI 2017}
}


